// HuggingFace Space è‡ªåŠ¨ä¿æ´» Worker
// url: "https://ic6-v3.hf.space",
// æ–°å¢åŠŸèƒ½ï¼šåœ¨ç•Œé¢æ˜¾ç¤ºSpaceçš„è®¿é—®URL
const HF_SPACES = [
  {
    name: "Space",
    region: "Global",
    url: "https://huggingface.co/spaces/ic6/v3",
    spaceName: "ic6/v3",
    description: "ä¸»è¦åº”ç”¨ç©ºé—´ï¼ˆå…è´¹ CPU ç‰ˆï¼‰"
  }
];

const CONFIG = {
  checkInterval: 15 * 60 * 1000,
  timeout: 30000,
  wakeUpThreshold: 1,
  retryCount: 1,
  kvPrefix: "space_"
};

class HuggingFaceKeeper {
  constructor() {
    this.lastUpdate = new Date();
    this.appStatus = {};
    this.hfApiToken = typeof HF_API_TOKEN !== "undefined" ? HF_API_TOKEN : "";
    this.hasKV = typeof SPACE_KV !== "undefined";
    if (!this.hasKV) {
      console.warn("æœªç»‘å®šSPACE_KVå‘½åç©ºé—´ï¼Œè¿è¡Œæ—¶é—´å°†æ— æ³•æŒä¹…åŒ–");
    }
  }

  async getSpaceState(spaceName) {
    if (!this.hasKV) return this.getDefaultState();
    
    try {
      const data = await SPACE_KV.get(CONFIG.kvPrefix + spaceName);
      return data ? JSON.parse(data) : this.getDefaultState();
    } catch (error) {
      console.error(`è·å–KVæ•°æ®å¤±è´¥: ${error.message}`);
      return this.getDefaultState();
    }
  }

  async saveSpaceState(spaceName, state) {
    if (!this.hasKV) return;
    
    try {
      await SPACE_KV.put(
        CONFIG.kvPrefix + spaceName,
        JSON.stringify(state),
        { expirationTtl: 30 * 24 * 60 * 60 }
      );
    } catch (error) {
      console.error(`ä¿å­˜KVæ•°æ®å¤±è´¥: ${error.message}`);
    }
  }

  getDefaultState() {
    return {
      consecutiveSleepCount: 0,
      lastWakeUpTime: 0,
      spaceStartTime: 0,
      lastKnownStatus: "unknown"
    };
  }

  formatDuration(ms) {
    if (typeof ms !== 'number' || isNaN(ms) || ms < 0) return "0ç§’";
    
    const second = Math.floor(ms / 1000) % 60;
    const minute = Math.floor(ms / (1000 * 60)) % 60;
    const hour = Math.floor(ms / (1000 * 60 * 60)) % 24;
    const day = Math.floor(ms / (1000 * 60 * 60 * 24));
    
    const parts = [];
    if (day > 0) parts.push(`${day}å¤©`);
    if (hour > 0 || parts.length > 0) parts.push(`${hour}æ—¶`);
    if (minute > 0 || parts.length > 0) parts.push(`${minute}åˆ†`);
    parts.push(`${second}ç§’`);
    
    return parts.join("");
  }

  async checkSpaceStatus(space) {
    const state = await this.getSpaceState(space.spaceName);
    const checkStartTime = Date.now();
    let retry = CONFIG.retryCount;
    
    while (retry > 0) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), CONFIG.timeout);
        const requestStartTime = Date.now();
        
        const response = await fetch(`https://huggingface.co/api/spaces/${space.spaceName}`, {
          method: "GET",
          signal: controller.signal,
          headers: {
            "User-Agent": "HF-Keeper/1.0",
            ...(this.hfApiToken ? { "Authorization": `Bearer ${this.hfApiToken}` } : {})
          }
        });
        
        const requestDuration = Date.now() - requestStartTime;
        clearTimeout(timeoutId);
        const spaceData = await response.json();
        const now = Date.now();

        let status, statusDesc, runningTime = "0ç§’";
        
        switch (spaceData.runtime?.stage) {
          case "RUNNING":
            status = "active";
            statusDesc = "æ­£å¸¸è¿è¡Œä¸­";
            
            if (state.lastKnownStatus !== "active") {
              state.spaceStartTime = now;
              console.log(`[${space.spaceName}] è®°å½•å¯åŠ¨æ—¶é—´: ${new Date(state.spaceStartTime).toLocaleString()}`);
            }
            
            runningTime = this.formatDuration(now - state.spaceStartTime);
            state.consecutiveSleepCount = 0;
            break;
            
          case "SLEEPING":
            status = "inactive";
            statusDesc = "å·²ç¡çœ ï¼ˆéœ€å”¤é†’ï¼‰";
            runningTime = "å·²ç¡çœ ";
            state.consecutiveSleepCount += 1;
            break;
            
          case "BUILDING":
          case "STARTING":
            status = "building";
            statusDesc = "æ„å»º/å¯åŠ¨ä¸­";
            runningTime = "å¯åŠ¨ä¸­";
            break;
            
          default:
            status = "error";
            statusDesc = "å¼‚å¸¸çŠ¶æ€";
            runningTime = "çŠ¶æ€å¼‚å¸¸";
        }
        
        state.lastKnownStatus = status;
        await this.saveSpaceState(space.spaceName, state);

        return {
          status,
          statusDesc,
          statusCode: response.status,
          responseTime: requestDuration,
          lastChecked: new Date(now).toISOString(),
          details: {
            sleepCount: state.consecutiveSleepCount,
            runningTime: runningTime,
            spaceStartTime: state.spaceStartTime
          }
        };

      } catch (error) {
        retry--;
        if (retry === 0) {
          const errorDuration = Date.now() - checkStartTime;
          await this.saveSpaceState(space.spaceName, state);
          return {
            status: "error",
            statusDesc: "æ£€æµ‹è¯·æ±‚å¤±è´¥",
            statusCode: 500,
            responseTime: errorDuration,
            lastChecked: new Date().toISOString(),
            details: { 
              runningTime: "æ£€æµ‹å¤±è´¥",
              spaceStartTime: state.spaceStartTime
            }
          };
        }
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }

  async wakeUpSpace(space) {
    const state = await this.getSpaceState(space.spaceName);
    try {
      const now = Date.now();
      
      if (now - state.lastWakeUpTime < 10 * 60 * 1000) {
        return {
          success: false,
          message: "10åˆ†é’Ÿå†…å·²å”¤é†’è¿‡",
          timestamp: new Date(now).toISOString()
        };
      }

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), CONFIG.timeout);

      const response = await fetch(space.url, {
        method: "GET",
        signal: controller.signal,
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        }
      });

      clearTimeout(timeoutId);
      state.lastWakeUpTime = now;
      state.spaceStartTime = now;
      state.consecutiveSleepCount = 0;
      await this.saveSpaceState(space.spaceName, state);

      return {
        success: response.ok,
        message: response.ok ? "å”¤é†’è¯·æ±‚å·²å‘é€" : `å”¤é†’å¤±è´¥ï¼ˆ${response.status}ï¼‰`,
        statusCode: response.status,
        timestamp: new Date(now).toISOString()
      };

    } catch (error) {
      await this.saveSpaceState(space.spaceName, state);
      return {
        success: false,
        message: `å”¤é†’å¼‚å¸¸: ${error.message}`,
        timestamp: new Date().toISOString()
      };
    }
  }

  async restartSpace(space) {
    if (!this.hfApiToken) {
      return { success: false, message: "æœªé…ç½®HF_API_TOKEN" };
    }

    const state = await this.getSpaceState(space.spaceName);
    try {
      const response = await fetch(`https://huggingface.co/api/spaces/${space.spaceName}/restart`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.hfApiToken}`,
          "Content-Type": "application/json"
        }
      });

      if (response.ok) {
        const now = Date.now();
        state.spaceStartTime = now;
      }

      await this.saveSpaceState(space.spaceName, state);
      return {
        success: response.ok,
        message: response.ok ? "é‡å¯è¯·æ±‚å·²å‘é€" : `é‡å¯å¤±è´¥ï¼ˆ${response.status}ï¼‰`,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      await this.saveSpaceState(space.spaceName, state);
      return { success: false, message: `é‡å¯å¼‚å¸¸: ${error.message}` };
    }
  }

  async getAllStatus() {
    const results = await Promise.all(HF_SPACES.map(space => this.checkSpaceStatus(space)));
    HF_SPACES.forEach((space, index) => {
      this.appStatus[space.name] = { ...space, ...results[index] };
    });
    this.lastUpdate = new Date();
    return this.appStatus;
  }

  /**
   * ç”Ÿæˆå‰ç«¯é¡µé¢ï¼ˆæ–°å¢Space URLæ˜¾ç¤ºï¼‰
   */
  generateHTML(statusData) {
    const lastUpdate = this.lastUpdate.toLocaleString("zh-CN");
    const spaceList = Object.values(statusData);
    const hasKV = this.hasKV ? "å·²å¯ç”¨" : "æœªå¯ç”¨ï¼ˆè¿è¡Œæ—¶é—´æ— æ³•æŒä¹…åŒ–ï¼‰";

    const getStatusColor = (status) => {
      switch (status) {
        case "active": return "#48c78e";
        case "inactive": return "#f14668";
        case "building": return "#ffe08a";
        case "error": return "#f14668";
        default: return "#363636";
      }
    };

    return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFè‡ªåŠ¨ä¿æ´»ç›‘æ§ç³»ç»Ÿ</title>
    <style>
        :root {
            --primary: #ff6b35;
            --dark: #363636;
            --light: #f5f5f5;
            --success: #48c78e;
            --warning: #ffe08a;
            --danger: #f14668;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--dark);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--light);
        }
        .header h1 { color: var(--primary); font-size: 2em; }
        .update-time { font-size: 0.9em; opacity: 0.8; }
        .space-card {
            margin-bottom: 25px;
            padding: 25px;
            border-radius: 15px;
            background: var(--light);
        }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* å…è®¸URLæ¢è¡Œ */
            margin-bottom: 20px;
            flex-wrap: wrap; /* å°å±å¹•è‡ªåŠ¨æ¢è¡Œ */
            gap: 10px;
        }
        .space-info {
            flex: 1;
            min-width: 250px;
        }
        .space-name { font-size: 1.4em; font-weight: 700; margin-bottom: 5px; }
        .space-url {
            font-size: 0.9em;
            word-break: break-all; /* é•¿URLè‡ªåŠ¨æ¢è¡Œ */
            margin-bottom: 5px;
        }
        .space-url a {
            color: #2563eb;
            text-decoration: none;
        }
        .space-url a:hover {
            text-decoration: underline;
        }
        .status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
            white-space: nowrap; /* çŠ¶æ€ä¸æ¢è¡Œ */
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-item {
            padding: 12px;
            border-radius: 10px;
            background: white;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5em;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 5px;
        }
        .metric-label { font-size: 0.85em; opacity: 0.8; }
        .action-buttons { display: flex; gap: 12px; flex-wrap: wrap; }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }
        .btn-wake { background: var(--success); color: white; }
        .btn-restart { background: var(--primary); color: white; }
        .btn-refresh { background: var(--dark); color: white; }
        .btn:hover { transform: translateY(-2px); opacity: 0.9; }
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid var(--light);
            font-size: 0.9em;
            opacity: 0.8;
        }
        @media (max-width: 768px) {
            .metrics { grid-template-columns: 1fr 1fr; }
            .card-header {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>HFè‡ªåŠ¨ä¿æ´»ç›‘æ§ç³»ç»Ÿ</h1>
            <div class="update-time">æœ€åæ›´æ–°: ${lastUpdate} | æŒä¹…åŒ–: ${hasKV}</div>
        </div>

        ${spaceList.map(space => `
        <div class="space-card">
            <div class="card-header">
                <div class="space-info">
                    <div class="space-name">${space.name} (${space.spaceName})</div>
                    <!-- æ–°å¢ï¼šæ˜¾ç¤ºSpaceçš„URLå¹¶æ·»åŠ é“¾æ¥ -->
                    <div class="space-url">
                        <a href="${space.url}" target="_blank" rel="noopener">${space.url}</a>
                    </div>
                </div>
                <div class="status-badge" style="background: ${getStatusColor(space.status)}20; color: ${getStatusColor(space.status)}">
                    <div class="status-dot" style="background: ${getStatusColor(space.status)}"></div>
                    ${space.statusDesc}
                </div>
            </div>

            <div class="metrics">
                <div class="metric-item">
                    <div class="metric-value">${space.responseTime || 0}ms</div>
                    <div class="metric-label">å“åº”æ—¶é—´</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value">${space.statusCode}</div>
                    <div class="metric-label">çŠ¶æ€ç </div>
                </div>
                <div class="metric-item">
                    <div class="metric-value running-time" 
                         data-start-time="${space.details.spaceStartTime}"
                         data-status="${space.status}">
                        ${space.details.runningTime}
                    </div>
                    <div class="metric-label">Spaceè¿è¡Œæ—¶é—´</div>
                </div>
                <div class="metric-item">
                    <div class="metric-value">${space.details.sleepCount}</div>
                    <div class="metric-label">è¿ç»­ç¡çœ æ¬¡æ•°</div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-refresh" onclick="refreshStatus()">ğŸ”„ åˆ·æ–°çŠ¶æ€</button>
                <button class="btn btn-wake" onclick="wakeUpSpace('${space.spaceName}')">â° æ‰‹åŠ¨å”¤é†’</button>
                <button class="btn btn-restart" onclick="restartSpace('${space.spaceName}')">ğŸ”„ æ‰‹åŠ¨é‡å¯</button>
            </div>
        </div>
        `).join("")}

        <div class="footer">
            <p>HF-Keeper | ä¿æ´»é—´éš”: ${CONFIG.checkInterval / 60000}åˆ†é’Ÿ | ç®¡ç† ${HF_SPACES.length} ä¸ª Space</p>
        </div>
    </div>

    <script>
        function formatDuration(ms) {
            if (typeof ms !== 'number' || isNaN(ms) || ms < 0) return "0ç§’";
            
            const second = Math.floor(ms / 1000) % 60;
            const minute = Math.floor(ms / (1000 * 60)) % 60;
            const hour = Math.floor(ms / (1000 * 60 * 60)) % 24;
            const day = Math.floor(ms / (1000 * 60 * 60 * 24));
            
            const parts = [];
            if (day > 0) parts.push(\`\${day}å¤©\`);
            if (hour > 0 || parts.length > 0) parts.push(\`\${hour}æ—¶\`);
            if (minute > 0 || parts.length > 0) parts.push(\`\${minute}åˆ†\`);
            parts.push(\`\${second}ç§’\`);
            
            return parts.join("");
        }

        function startRealTimeUpdate() {
            setInterval(() => {
                document.querySelectorAll('.running-time[data-status="active"]').forEach(el => {
                    const startTime = Number(el.dataset.startTime);
                    const now = Date.now();
                    const durationMs = now - startTime;
                    el.textContent = formatDuration(durationMs > 0 ? durationMs : 0);
                });
            }, 1000);
        }

        window.onload = startRealTimeUpdate;

        function refreshStatus() { window.location.reload(); }

        async function wakeUpSpace(spaceName) {
            try {
                const res = await fetch(\`/wake?space=\${spaceName}\`);
                const data = await res.json();
                alert(data.success ? \`âœ… \${data.message}\` : \`âŒ \${data.message}\`);
                setTimeout(refreshStatus, 3000);
            } catch (e) { alert(\`æ“ä½œå¤±è´¥: \${e.message}\`); }
        }

        async function restartSpace(spaceName) {
            if (!confirm("ç¡®å®šé‡å¯ï¼ŸæœåŠ¡ä¼šä¸­æ–­10-30ç§’")) return;
            try {
                const res = await fetch(\`/restart?space=\${spaceName}\`);
                const data = await res.json();
                alert(data.success ? \`âœ… \${data.message}\` : \`âŒ \${data.message}\`);
                setTimeout(refreshStatus, 5000);
            } catch (e) { alert(\`æ“ä½œå¤±è´¥: \${e.message}\`); }
        }

        setInterval(refreshStatus, 5 * 60 * 1000);
    </script>
</body>
</html>`;
  }
}

async function handleRequest(request) {
  const keeper = new HuggingFaceKeeper();
  const url = new URL(request.url);
  const spaceName = url.searchParams.get("space");
  const targetSpace = HF_SPACES.find(s => s.spaceName === spaceName) || HF_SPACES[0];

  if (url.pathname === "/wake") {
    if (!targetSpace) return new Response(JSON.stringify({ success: false, message: "Spaceä¸å­˜åœ¨" }), { headers: { "Content-Type": "application/json" } });
    const result = await keeper.wakeUpSpace(targetSpace);
    return new Response(JSON.stringify(result), { headers: { "Content-Type": "application/json" } });
  }

  if (url.pathname === "/restart") {
    if (!targetSpace) return new Response(JSON.stringify({ success: false, message: "Spaceä¸å­˜åœ¨" }), { headers: { "Content-Type": "application/json" } });
    const result = await keeper.restartSpace(targetSpace);
    return new Response(JSON.stringify(result), { headers: { "Content-Type": "application/json" } });
  }

  if (url.pathname === "/status") {
    const status = await keeper.getAllStatus();
    return new Response(JSON.stringify(status, null, 2), { headers: { "Content-Type": "application/json" } });
  }

  const status = await keeper.getAllStatus();
  const html = keeper.generateHTML(status);
  return new Response(html, { headers: { "Content-Type": "text/html; charset=utf-8" } });
}

async function handleScheduledEvent() {
  console.log(`[å®šæ—¶ä¿æ´»] å¼€å§‹æ‰§è¡Œï¼ˆ${new Date().toLocaleString()}ï¼‰`);
  const keeper = new HuggingFaceKeeper();

  try {
    const statusData = await keeper.getAllStatus();
    const spaceList = Object.values(statusData);

    for (const space of spaceList) {
      if (space.status === "inactive" && space.details.sleepCount >= CONFIG.wakeUpThreshold) {
        console.log(`[${space.spaceName}] è§¦å‘è‡ªåŠ¨å”¤é†’`);
        const wakeResult = await keeper.wakeUpSpace(space);
        
        if (!wakeResult.success && keeper.hfApiToken) {
          console.log(`[${space.spaceName}] å°è¯•é‡å¯`);
          await keeper.restartSpace(space);
        }
      }
    }
  } catch (error) {
    console.error(`[å®šæ—¶ä¿æ´»] å¼‚å¸¸:`, error.message);
  }
}

addEventListener("fetch", event => {
  event.respondWith(handleRequest(event.request));
});

addEventListener("scheduled", event => {
  event.waitUntil(handleScheduledEvent());
});
